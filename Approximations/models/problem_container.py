import numpy as np
from copy import copy

from   Approximations.models.data_models.R_matrix_full        import RMatrixFull
from   Approximations.models.fitting_models.reich_moore_model import ReichMoore
from   Approximations.tools.fitting                           import gradient_Descent
from   Approximations.tools.fitting                           import levenberg_Marquardt
import Approximations.tools.distributions                     as     Distributions





class Problem():
    data_model_formats = [RMatrixFull]
    fit_model_formats  = [ReichMoore]
    fitting_algorithms = [gradient_Descent,
                          levenberg_Marquardt]

    def __init__(self,
                 molecular_information,
                 interaction_information,
                 model_information,
                 fitting_parameters,
                 selections):
        # molecular_information:   Incident Name                 _
        #                          Incident Nucleons             #
        #                          Incident Protons              #
        #                          Departing Name                _
        #                          Departing Nucleons            #
        #                          Departing Protons             #
        #                          Compound Name                 _
        #                          Compound Nucleons             #
        #                          Compound Protons              #
        #
        # interaction_information: Separation Energy             ev
        #                          Gamma Variance                ev
        #                          Neutron Variance              ev
        #                          Excited States                ev
        #                          Number Levels                 #
        #                          Resonance Levels              ev
        #                          ↳ Generated by...
        #                             Resonance Distance         ev
        #                             Resonance Average Spacing  ev
        #
        # model_information:       Energy Grid                   ev
        #                          ↳ Generated by...
        #                             Energy Grid Size           #
        #                             Energy Grid Buffer         ev
        #
        # fitting_parameters:      Depends on algorithm choice
        #
        # selections:              Data Model
        #                              1: Complete R-Matrix
        #                          Fit Model
        #                              1: Reich Moore
        #                          Fit Method
        #                              1: Built in gradient descent
        #                              2: Built in Levenburg-Marquardt

        self.molecular_information   = molecular_information
        self.interaction_information = copy(interaction_information)
        self.model_information       = model_information
        self.fitting_parameters      = fitting_parameters
        self.selections              = selections

        self.sample_Information()

        self.data_model = self.form_Model(self.data_model_formats,
                                          self.selections["Data Model"])
        self.fit_model  = self.form_Model(self.fit_model_formats,
                                          self.selections["Fit Model"])

        self.fit_Call = self.form_Fit_Call(self.fitting_algorithms,
                                           self.selections["Fit Method"])
        
        self.data     = self.generate_Data()

    

    def form_Model(self,
                   model_formats,
                   model_selection):
        model = model_formats[model_selection-1]
        return(model(self.molecular_information,
                     self.interaction_information,
                     self.model_information))
    


    def form_Fit_Call(self,
                      fitting_algorithms,
                      algorithm_choice):
        fitting_alg = fitting_algorithms[algorithm_choice-1]
        return(fitting_alg(self.fit_model,
                           self.fitting_parameters,
                           0))



    def generate_Data(self):
        return(self.data_model.generate_Data())
    


    def sample_Information(self):
        if((not("Resonance Levels"          in self.interaction_information)) and   
               ("Resonance Distance"        in self.interaction_information)  and
               ("Resonance Average Spacing" in self.interaction_information)):
            assert "Number Levels"          in self.interaction_information, "Information Gen Failed: Number Levels not provided in interaction_information"
            
            levels    = np.zeros(self.interaction_information["Number Levels"])
            levels[0] = self.interaction_information["Resonance Distance"]
            for idx in range(1, self.interaction_information["Number Levels"]):
                levels[idx] = Distributions.sample_Wigner_InvCDF(1)*self.interaction_information["Resonance Average Spacing"] + levels[idx-1]
            self.interaction_information["Resonance Levels"] = levels

        if((not("Energy Grid"          in self.model_information)) and
               ("Energy Grid Size"     in self.model_information)  and
               ("Energy Grid Buffer"   in self.model_information)):
           assert "Resonance Levels"   in self.interaction_information, "Information Gen Failed: Resonance Levels not provided in interaction_information"

           self.model_information["Energy Grid"] = np.linspace(self.interaction_information["Resonance Levels"][0]  - self.model_information["Energy Grid Buffer"],
                                                               self.interaction_information["Resonance Levels"][-1] + self.model_information["Energy Grid Buffer"],
                                                               self.model_information["Energy Grid Size"])
    


    def get_Initial_Guess(self):
        true_matrix = self.data_model.math_model.get_Gamma_Matrix()
        best_guess  = np.zeros(self.interaction_information["Number Levels"]*2)

        best_guess[:self.interaction_information["Number Levels"]]  = true_matrix[:,0]
        best_guess[self.interaction_information["Number Levels"]:]  = np.ones(self.interaction_information["Number Levels"])*self.interaction_information["Gamma Variance"]
        
        return(best_guess)