import numpy as np

from   Approximations.models.data_models.R_matrix_full        import R_Matrix_Full
from   Approximations.models.fitting_models.reich_moore_model import Reich_Moore
from   Approximations.tools.fitting                           import gradientDescent
from   Approximations.tools.fitting                           import levenbergMarquardt
import Approximations.tools.distributions                     as     distributions





class Problem():
    data_model_formats = [R_Matrix_Full]
    fit_model_formats  = [Reich_Moore]
    fitting_algorithms = [gradientDescent,
                          levenbergMarquardt]

    def __init__(self,
                 molecular_information,
                 interaction_information,
                 model_information,
                 fitting_parameters,
                 selections):
        # molecular_information:   Incident Name                 _
        #                          Incident Nucleons             #
        #                          Incident Protons              #
        #                          Departing Name                _
        #                          Departing Nucleons            #
        #                          Departing Protons             #
        #                          Compound Name                 _
        #                          Compound Nucleons             #
        #                          Compound Protons              #
        #
        # interaction_information: Separation Energy             ev
        #                          Gamma Variance                ev
        #                          Neutron Variance              ev
        #                          Excited States                ev
        #                          Number Levels                 #
        #                          Resonance Levels              ev
        #                          ↳ Generated by...
        #                             Resonance Distance         ev
        #                             Resonance Average Spacing  ev
        #
        # model_information:       Energy Grid                   ev
        #                          ↳ Generated by...
        #                             Energy Grid Size           #
        #                             Energy Grid Buffer         ev
        #
        # fitting_parameters:      Depends on algorithm choice
        #
        # selections:              Data Model
        #                              1: Complete R-Matrix
        #                          Fit Model
        #                              1: Reich Moore
        #                          Fit Method
        #                              1: Built in gradient descent
        #                              2: Built in Levenburg-Marquardt

        self.molecular_information   = molecular_information
        self.interaction_information = interaction_information
        self.model_information       = model_information
        self.fitting_parameters      = fitting_parameters
        self.selections              = selections

        self.sampleInformation()

        self.data_model = self.formModel(self.data_model_formats,
                                         self.selections["Data Model"])
        self.fit_model  = self.formModel(self.fit_model_formats,
                                         self.selections["Fit Model"])

        self.fit_call = self.formFitCall(self.fitting_algorithms,
                                         self.selections["Fit Method"])
        
        self.generateData()

    

    def formModel(self,
                  model_formats,
                  model_selection):
        model = model_formats[model_selection-1]
        return(model(self.molecular_information,
                     self.interaction_information,
                     self.model_information))
    


    def formFitCall(self,
                    fitting_algorithms,
                    algorithm_choice):
        fitting_alg = fitting_algorithms[algorithm_choice-1]
        return(fitting_alg(self.fit_model,
                           self.fitting_parameters,
                           0))



    def generateData(self):
        self.data=self.data_model.generateData()
    


    def sampleInformation(self):
        if((not("Resonance Levels"          in self.interaction_information)) and   
               ("Resonance Distance"        in self.interaction_information)  and
               ("Resonance Average Spacing" in self.interaction_information)):
            assert "Number Levels"   in self.interaction_information, "Information Gen Failed: Number Levels not provided in interaction_information"
            levels=np.zeros(self.interaction_information["Number Levels"])
            levels[0]=self.interaction_information["Resonance Distance"]
            for idx in range(1,self.interaction_information["Number Levels"]):
                levels[idx]=distributions.sample_wigner_invCDF(1)*self.interaction_information["Resonance Average Spacing"]+levels[idx-1]
            self.interaction_information["Resonance Levels"]=levels

        if((not("Energy Grid"        in self.model_information)) and
               ("Energy Grid Size"   in self.model_information)  and
               ("Energy Grid Buffer" in self.model_information)):
           assert "Resonance Levels"   in self.interaction_information, "Information Gen Failed: Resonance Levels not provided in interaction_information"
           self.model_information["Energy Grid"]=np.linspace(self.interaction_information["Resonance Levels"][0]  - self.model_information["Energy Grid Buffer"],
                                                             self.interaction_information["Resonance Levels"][-1] + self.model_information["Energy Grid Buffer"],
                                                             self.model_information["Energy Grid Size"])
    


    def getInitialGuess(self):
        true_matrix      = self.data_model.math_model.get_gamma_matrix()
        best_guess       = np.zeros(self.interaction_information["Number Levels"]*2)

        best_guess[:self.interaction_information["Number Levels"]]  = true_matrix[:,0]
        best_guess[self.interaction_information["Number Levels"]:]  = np.ones(self.interaction_information["Number Levels"])*self.interaction_information["Gamma Variance"]
        
        return(best_guess)