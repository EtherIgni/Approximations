import numpy as np
from copy import copy

from   Approximations.models.data_models.R_matrix_full        import RMatrixFull
from   Approximations.models.data_models.Syndat               import SyndatData
from   Approximations.models.fitting_models.reich_moore_model import ReichMoore
from   Approximations.tools.fitting                           import scipy_Method, scipy_Method_uncertainty
import Approximations.tools.distributions                     as     Distributions





class Problem():
    data_model_formats = [RMatrixFull,  SyndatData]
    fit_model_formats  = [ReichMoore]
    fitting_algorithms = [scipy_Method, scipy_Method_uncertainty]

    def __init__(self,
                 molecular_information,
                 interaction_information,
                 model_information,
                 fitting_parameters,
                 selections):
        # molecular_information:   Incident Name                 _
        #                          Incident Nucleons             #
        #                          Incident Protons              #
        #                          Departing Name                _
        #                          Departing Nucleons            #
        #                          Departing Protons             #
        #                          Target Name                   _
        #                          Target Nucleons               #
        #                          Target Protons                #
        #
        # interaction_information: Separation Energy             ev
        #                          Elastic Variance              ev
        #                          Elastic Radius                ev
        #                          Capture Variance              ev
        #                          Capture Radius                ev
        #                          Capture Ell                   ev
        #                          Excited States                ev
        #                          Number Levels                 #
        #                          Resonance Levels              ev
        #                          ↳ Generated by...
        #                             Resonance Distance         ev
        #                             Resonance Average Spacing  ev
        #
        # model_information:       Energy Grid                   ev
        #                          ↳ Generated by...
        #                             Energy Grid Size           #
        #                             Energy Grid Buffer         ev
        #
        # fitting_parameters:      Depends on algorithm choice
        #
        # selections:              Data Model
        #                              1: Complete R-Matrix
        #                              2: R-Matrix w/ Synthetic Data
        #                          Fit Model
        #                              1: Reich Moore
        #                          Fit Method
        #                              1: Least squares method from SciPy
        #                              2: Least Squares with Uncertainty

        self.molecular_information   = copy(molecular_information)
        self.interaction_information = copy(interaction_information)
        self.model_information       = copy(model_information)
        self.fitting_parameters      = copy(fitting_parameters)
        self.selections              = copy(selections)

        self.sample_Information()
        
        self.true_gamma_matrix = self.interaction_information["Gamma Matrix"]

        self.data_model = self.form_Model(self.data_model_formats,
                                          self.selections["Data Model"])
        self.fit_model  = self.form_Model(self.fit_model_formats,
                                          self.selections["Fit Model"])

        self.fit_Call = self.form_Fit_Call(self.fitting_algorithms,
                                           self.selections["Fit Method"])
        
        self.data     = self.generate_Data()

    

    def form_Model(self,
                   model_formats,
                   model_selection):
        model = model_formats[model_selection-1]
        return(model(self.molecular_information,
                     self.interaction_information,
                     self.model_information))
    


    def form_Fit_Call(self,
                      fitting_algorithms,
                      algorithm_choice):
        fitting_alg = fitting_algorithms[algorithm_choice-1]
        return(fitting_alg(self.fit_model,
                           self.fitting_parameters,
                           0))



    def generate_Data(self):
        return(self.data_model.generate_Data())
    


    def sample_Information(self):
        if((not("Excited States"           in self.interaction_information)) and
               ("Excitation Model"         in self.interaction_information)  and
               ("Excitation Limits"        in self.interaction_information)  and
               ("Number Excitation States" in self.interaction_information)):
            
            num_states     = self.interaction_information["Number Excitation States"]
            excited_states = np.zeros(num_states)
            
            if(self.interaction_information["Excitation Model"] == "Flat"):
                excited_states[1:] = np.random.rand(num_states-1)*self.interaction_information["Excitation Limits"][0]
                
            if(self.interaction_information["Excitation Model"] == "Bimodal"):
                mode_cut = int(np.floor((num_states-1)/2))
                limits   = self.interaction_information["Excitation Limits"]
                
                excited_states[1:mode_cut+1] = np.random.rand(mode_cut)*limits[0]
                excited_states[mode_cut+1:]  = np.random.rand(num_states-1-mode_cut)*(limits[2]-limits[1])+limits[1]
            
            excited_states = np.sort(excited_states)
                
            self.interaction_information["Excited States"] = excited_states
                
        if((not("Resonance Levels"          in self.interaction_information)) and   
               ("Resonance Distance"        in self.interaction_information)  and
               ("Resonance Average Spacing" in self.interaction_information)):
            assert "Number Levels"          in self.interaction_information, "Information Gen Failed: Number Levels not provided in interaction_information"
            
            levels    = np.zeros(self.interaction_information["Number Levels"])
            levels[0] = self.interaction_information["Resonance Distance"]
            for idx in range(1, self.interaction_information["Number Levels"]):
                levels[idx] = Distributions.sample_Wigner_InvCDF(1)*self.interaction_information["Resonance Average Spacing"] + levels[idx-1]
            self.interaction_information["Resonance Levels"] = levels

        if((not("Energy Grid"          in self.model_information)) and
               ("Energy Grid Size"     in self.model_information)  and
               ("Energy Grid Buffer"   in self.model_information)):
           assert "Resonance Levels"   in self.interaction_information, "Information Gen Failed: Resonance Levels not provided in interaction_information"

           self.model_information["Energy Grid"] = np.linspace(self.interaction_information["Resonance Levels"][0]  - self.model_information["Energy Grid Buffer"],
                                                               self.interaction_information["Resonance Levels"][-1] + self.model_information["Energy Grid Buffer"],
                                                               self.model_information["Energy Grid Size"])
        
        if((not("Gamma Matrix"        in self.interaction_information))and
               ("Elastic Variance"    in self.interaction_information)and
               ("Capture Variance"    in self.interaction_information)):
            assert "Number Levels"    in self.interaction_information, "Information Gen Failed: Number Levels not provided in interaction_information"
            assert "Resonance Levels" in self.interaction_information, "Information Gen Failed: Resonance Levels not provided in interaction_information"
            
            num_levels                                   = self.interaction_information["Number Levels"]
            num_channels                                 = len(self.interaction_information["Excited States"])+1
            
            gamma_matrix                                 = np.zeros((num_levels, num_channels))
            gamma_matrix[:,0]                            = np.random.normal(0, self.interaction_information["Elastic Variance"], num_levels)
            gamma_matrix[:,1:]                           = np.random.normal(0, self.interaction_information["Capture Variance"], num_levels*(num_channels-1)).reshape((num_levels, (num_channels-1)))
            
            self.interaction_information["Gamma Matrix"] = gamma_matrix
    


    def get_Initial_Guess(self):
        return(self.fit_model.get_Initial_Guess(self.true_gamma_matrix))